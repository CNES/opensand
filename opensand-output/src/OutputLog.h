/*
 *
 * OpenSAND is an emulation testbed aiming to represent in a cost effective way a
 * satellite telecommunication system for research and engineering activities.
 *
 *
 * Copyright Â© 2020 TAS
 *
 *
 * This file is part of the OpenSAND testbed.
 *
 *
 * OpenSAND is free software : you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see http://www.gnu.org/licenses/.
 *
 */

/**
 * @file OutputLog.h
 * @brief The OutputLog class represent a log
 *        (debug, info, notice, warning, error, critical)
 *        generated by the application.
 *        Its level can be adjusted according to what we want to display
 *        except for events
 * @author Fabrice Hobaya     <fhobaya@toulouse.viveris.com>
 * @author Mathias Ettinger   <mathias.ettinger@viveris.fr>
 */


#ifndef _OUTPUT_LOG_H
#define _OUTPUT_LOG_H

#include <string>
#include <vector>
#include <memory>
#include <cstdarg>

#include "OutputMutex.h"
#include "OutputHandler.h"
#include "Printf.h"


/**
 * @brief log severity levels
 **/
enum log_level_t : unsigned int
{
  // Sorted from the least important to the most important
  // with the same id as in syslog except for event
  LEVEL_DEBUG     = 7, /*!< Debug level */
  LEVEL_INFO      = 6, /*!< Information level */
  LEVEL_NOTICE    = 5, /*!< Notice level */
  LEVEL_WARNING   = 4, /*!< Warning level */
  LEVEL_ERROR     = 3, /*!< Error level */
  LEVEL_CRITICAL  = 2, /*!< Critical level */
  LEVEL_EVENT     = 10,  /*!< Event level */
};


/**
 * @class Represent a log
 */
class OutputLog
{
	friend class Output;

 public:
	virtual ~OutputLog();

	/**
	 * @brief Set the current log display level
	 *
	 * @param level  the current log display level
	 */
	virtual void setDisplayLevel(log_level_t level);

	/**
	 * @brief Get the current log display level
	 *
	 * @return the current log display level
	 */
	log_level_t getDisplayLevel(void) const;

	/**
	 * @brief Get the current log display level as a string
	 *
	 * @return a string representation of the current log display level
	 */
	std::string getDisplayLevelString() const;

	/**
	 * @brief Get the name of the log
	 *
	 * @return the name of the log
	 **/
	inline const std::string getName() const { return this->name; };

	void addHandler(std::shared_ptr<LogHandler> handler);

	template<typename... Args>
	void sendLog(log_level_t log_level, char const * const msg_format, Args const & ... args) const;

 protected:
	/**
	 * @brief create a log
	 *
	 * @param display_level  The current log level
	 * @param name           The log name
	 */
	OutputLog(log_level_t display_level, const std::string &name);

	/// The levels string representation
	const static char *levels[];

 private:
	std::string name;
	log_level_t display_level;
	std::vector<std::shared_ptr<LogHandler>> handlers;

	mutable OutputMutex lock;
};


template<typename... Args>
void OutputLog::sendLog(log_level_t log_level, char const * const msg_format, Args const & ... args) const
{
	if (log_level > display_level)
	{
		return;
	}

	std::string level = levels[log_level];
	std::string message = Format(msg_format, args...);
	for (auto &&handler: handlers)
	{
		handler->emitLog(name, level, message);
	}
}


#endif
